#+title: Posts
#+hugo_base_dir: resources/
#+hugo_front_matter_format: yaml

* Posts
** Task ordering
:PROPERTIES:
:EXPORT_FILE_NAME: task-ordering
:EXPORT_HUGO_PUBLISHDATE: <2023-07-18 Tue 09:21>
:ID:       6f882dc7-e068-44da-8cb3-00f983bcfd63
:END:
Lily and I wear [[https://web.archive.org/web/20230717004606/https://www.shutterstock.com/image-photo/two-invisible-dental-teeth-aligners-on-1807717714][retainers]] every night. We clean them daily using a regular toothbrush and liquid hand soap. Cleaning these retainers at the end of the day, before bed, is one of my least favorite chores. I dealt with that for a long time! I would delay, put it off, getting in to bed fifteen or twenty minutes later than I would have if I would have just washed the damn things as soon as I finished flossing and brushing my teeth. For a while, I tried cleaning the retainers before the flossing and tooth brushing, but that didn't improve things. After a while I figured out a way to resolve my issue: I now clean our retainers /in the morning/, immediately after brushing my teeth. It's the easiest thing in the world at that point in the day, but feels impossible at night.

Though my issue with the nighttime retainer cleaning is probably just a classic ADHD Moment, after I got the morning thing going, it got me thinking about task ordering. It's not a novel idea that tasks have orderings. A simple example is a task where you don't have the knowledge to accomplish it yet. You can't accomplish it without getting the knowledge first. Not every ordering is "strict", though -- the retainer cleaning saga involved at least three orderings.
#+begin_src text
floss -> nighttime tooth brushing -> clean retainers -> get in bed

clean retainers -> floss -> nighttime tooth brushing -> get in bed

wake up -> random morning things -> morning tooth brushing -> clean retainers -> [ .. the whole day .. ] -> floss -> nighttime tooth brushing -> get in bed
#+end_src

Once I had noticed that, I realized I'd seen variations of the concept before.

[[https://www.structuredprocrastination.com/][Structured Procrastination]] is well known, and one of my favorite essays of its kind. It's about ordering your tasks so that there's always something you don't want to do (but have committed to doing) at the "end of the list."

CPUs do [[https://en.wikipedia.org/wiki/Out-of-order_execution][out-of-order execution]].

[[https://charity.wtf/2017/05/11/the-engineer-manager-pendulum/][The Engineer/Manager Pendulum]] is about flipping the traditional
#+begin_src text
Start Career -> IC -> Management -> End Career
#+end_src
order into
#+begin_src text
Start Career -> IC -> Management -> IC -> Management -> End career
                                    ↑         ↓
                                     ↖_______↙
#+end_src

There are algorithms that utilize [[https://en.wikipedia.org/wiki/Amortized_analysis][amortization]] to improve their average performance. C++'s =std::vector= notably [[https://stackoverflow.com/a/5232342/5692730][uses this technique]] to achieve (amortized) constant cost when growing in capacity. This is a reordering of tasks from this expensive loop:
#+begin_src text
Make vector with capacity 1 -> add item -> increase capacity
                                    ↑         ↓
                                     ↖_______↙
#+end_src
To one that minimizes the number of times we =increase capacity=.

[[https://en.wikipedia.org/wiki/DFA_minimization][DFA minimization]] is an algorithm for reducing the number of states in a (deterministic and finite) automaton. We remove states if we can show they're equivalent. Now that I think about it, removal is only sort of like reordering. There's a world of difference between "I clean my retainers in the morning instead of at night" and "I don't clean my retainers".

Project management tools are all about task reordering.

Task reordering isn't a magical solution. I despise washing our coffee pot and can't find a good time of day to do it. Part of the problem is that we don't use it every day; some mornings we have tea, yerba mate, or go out for coffee instead. Maybe if I worked the washing of the coffee pot into a fixed place in my daily routine, I would realize it's in the wrong place in the routine, place it correctly, and then be able to wash it as easily as I clean the retainers.

Maybe part of the problem is that reordering tasks only works for low-friction tasks where the cost to start doing them is low. Some tasks are really four or five tasks dressed in a trench coat disguised as a single task, and it's not always easy to tell that from a todo list. Comparing "cleaning the retainers" to "washing the coffee pot" doesn't convey any of this context. But cleaning the retainers takes two minutes at most, while the coffee pot involves making sure there's space on the dish drying rack, ensuring there's space in the sink, putting on the dishwashing gloves, then washing the four separate pieces of the coffee pot ensemble.

Those first two steps (of the single "washing the coffee pot" task!) might create a cascade of new tasks. If the dishes on the drying rack are wet, we'd have to dry them then put them away. Is the sink full because the dishwasher is running? If that's the case, maybe there isn't space in the sink to wash the coffee pot. This can go on and on.

Getting things done is hard, especially with executive function disorders like ADHD. Thinking about the order of tasks has helped me a great deal.

** Setting up mu4e with iCloud custom domains with Doom Emacs on Arch Linux
:PROPERTIES:
:EXPORT_FILE_NAME: mu4e_doom_emacs
:EXPORT_HUGO_PUBLISHDATE: <2022-04-18 Mon 20:32>
:END:
Here's how I set up =mu4e= with Doom Emacs on Arch Linux for my custom domain
hosted on iCloud. I'm using =mbsync=, =mu=, and =msmpt=. I originally went with
a systemd timer as detailed in the first two sections as recommended in the [[https://wiki.archlinux.org/title/isync#Calling_mbsync_automatically][Arch
wiki]], but =mu4e= actually has a built-in functionality to deal with this for us.
Note that what I've written here is the /minimum/ I needed to do to actually
sync, send, and read emails from =emacs=. There's a lot more you can do.

*** Configuration files

In =init.el=, under =:email=
#+begin_src emacs-lisp
(mu4e +org)
#+end_src

=config.el=:
#+begin_src emacs-lisp
(set-email-account! "icloud"
  '((mu4e-sent-folder       . "/icloud/Sent")
    (mu4e-drafts-folder     . "/icloud/Drafts")
    (mu4e-trash-folder      . "/icloud/Trash")
    (mu4e-refile-folder     . "/icloud/Archive")
    (smtpmail-smtp-user     . "lucianolaratelli")
    (mu4e-compose-signature . "\n\nLuciano"))
  t)

(after! mu4e
  (setq sendmail-program (executable-find "msmtp")
        send-mail-function #'smtpmail-send-it
        smtpmail-stream-type 'starttls
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-send-mail-function #'message-send-mail-with-sendmail))
#+end_src

In =$HOME/.config/system/user/mbsync.timer=:
#+begin_src systemd
[Unit]
Description=Mailbox synchronization timer

[Timer]
OnBootSec=1m
OnUnitActiveSec=5m
Unit=mbsync.service

[Install]
WantedBy=timers.target
#+end_src

=$HOME/.config/system/user/mbsync.service=:
#+begin_src systemd
[Unit]
Description=Mailbox synchronization service

[Service]
Type=oneshot
ExecStart=/usr/bin/mbsync --verbose --all

[Install]
WantedBy=default.target
#+end_src

=$HOME/.mbsyncrc=:
#+begin_src config
# imap account information
IMAPAccount icloud
Host imap.mail.me.com
User lucianolaratelli@icloud.com
PassCmd "secret-tool lookup email luciano@laratel.li"
SSLType IMAPS
Port 993

# remote storage (use the imap account specified above)
IMAPStore icloud-remote
Account icloud

# local storage
MaildirStore icloud-local
Path ~/Dropbox/mailbox/icloud/
Inbox ~/Dropbox/mailbox/icloud*Inbox
Subfolders Verbatim

# channel to remote storage
Channel icloud
Far :icloud-remote:
Near :icloud-local:
Patterns *
Create Near
Sync All
Expunge Both
SyncState *
#+end_src

The crucial part when you're using a custom domain hosted on iCloud is to use
your *iCloud email address* instead of the custom one. I thought this was a bug
with custom domains (I've run into another one) but I called Apple's support and
they told me I needed to use the iCloud email address. You can find this on an
iPhone or iPad by going to Settings, tapping on your name up top, and tapping on
=Name, Phone Numbers, Email=. I had =@me.com= and =@icloud.com= emails there. I
went with the =@icloud.com= one. [[https://support.apple.com/en-us/HT202304][Apple's docs]] on third-party iCloud clients say
you can use just the part before the domain, but I included the whole thing just
in case. Without further ado, =$HOME/.msmptrc=:
#+begin_src config
defaults
tls_trust_file /etc/ssl/certs/ca-certificates.crt
logfile ~/.maildir/msmtp.log
protocol smtp

account icloud
auth on
host smtp.mail.me.com
port 587
protocol smtp
from luciano@laratel.li
user ${ICLOUD_EMAIL_ADDRESS}
passwordeval "secret-tool lookup email luciano@laratel.li"
tls on
tls_starttls on

account default : icloud
#+end_src

I have =tls= and =tls_starttls= both on. I think I only need one of these, but I
don't want to muck with testing my mail configuration to get a blog post out.
You might need one, the other, or both. Exercise for the reader!

I was originally using =gpg= as described by Erich Grunewald in his very helpful
[[https://www.erichgrunewald.com/posts/setting-up-gmail-in-doom-emacs-using-mbsync-and-mu4e/#(optionally)-store-your-password-in-an-encrypted-file][post]], but unlocking my yubikey every five minutes became a pain and I figured my
login keychain was secure enough for my (unsophisticated) threat model.

*** Install and enable packages

#+begin_src bash
yay mbsync
sudo pacman -S msmtp
yay mu mu4e # impossible to find mu otherwise

mkdir -p ~/home/Dropbox/mailbox/icloud
mbsync -Va
mu init -m ~/Dropbox/mailbox --my-address luciano@laratel.li
mu index

systemctl enable --user --now mbsync
systemctl enable --user --now mbsync.timer

doom sync
#+end_src

At this point you can run =emacs=, =<SPC> o m=, and get to emailin'!

*** Moving away from systemd

This was working fine but I wasn't getting in-=emacs= notifications when new
emails came in, even though =mbsync= was running on schedule! So I got rid of
the =mbsync.timer= service with =systemctl disable --now --user mbsync.timer=. I
kept =mbsync.service= so that my email syncs when I log in for the day. Then, in
my =config.el=:

#+begin_src emacs-lisp
(after! mu4e (setq mu4e-get-mail-command "mbsync --verbose --all"
                   mu4e-update-interval 300))
#+end_src

I restarted =emacs= and I was good to go.

*** Resources
Tecosaur's awe-inspiring [[https://tecosaur.github.io/emacs-config/config.html#fetching-systemd][config]]

The already-mentioned [[https://www.erichgrunewald.com/posts/setting-up-gmail-in-doom-emacs-using-mbsync-and-mu4e/#(optionally)-store-your-password-in-an-encrypted-file][post]] from Erich Grunewald

The Doom Emacs =mu4e= module [[https://github.com/hlissner/doom-emacs/tree/develop/modules/email/mu4e][documentation]] (also from Tecosaur)

[[https://github.com/kzar/davemail/blob/main/.mbsyncrc][davemail]]

This [[https://macowners.club/posts/email-emacs-mu4e-macos/#storing-trusted-root-certificates][article]], though it focuses on macOS
** Using CLJS and shadow-cljs for serverless DigitalOcean Functions
:PROPERTIES:
:EXPORT_FILE_NAME: cljs-digitalocean-serverless
:EXPORT_HUGO_PUBLISHDATE: <2023-01-11 Wed 20:08>
:END:

DigitalOcean (DO) [[https://www.digitalocean.com/products/functions][Functions]]: "a serverless computing solution that runs on-demand, enabling you to focus on your code, scale instantly with confidence, and save costs by eliminating the need to maintain servers." Since I'm a fanatic, I would like to write some Clojure for my serverless use case. Because DO offers Node as a runtime, we're able to use ClojureScript to write code and deploy it to the serverless, er, server.

Source code for this blog post is [[https://git.sr.ht/~luciano/cljs-digitalocean-serverless-function][available]].

You'll need a DO account. Log in, select the appropriate team, then select =Functions= on the left-hand column. Create a function namespace and you're ready to go.

Next we need the =doctl= binary. Here's what I did:
#+begin_src bash
brew install doctl
doctl auth init
doctl serverless install
doctl serverless connect
#+end_src

This gets you authenticated with DO so you can deploy from the command line.

#+begin_src bash
npx create-cljs-project do_serverless
cd do_serverless
#+end_src

Now, let's edit the generated =shadow.cljs= a bit. Add this map as the value under =:builds=:
#+begin_src clojure
{:core {:target :node-script
         :main core/main
         :output-to "packages/do-serverless/core/core.js"}}
#+end_src

Create =src/main/core.cljs= and define =main= in it:
#+begin_src clojure
(ns core)

(defn main [])
#+end_src

Create =packages/do-serverless/core/package.json= with this in it:
#+begin_src json
{
  "name": "core",
  "version": "1.0.0",
  "description": "CLJS on DO!",
  "main": "core.js",
  "dependencies": {
    "source-map-support": "^0.5.21"
  },
  "devDependencies": {}
}
#+end_src

Lastly, create =project.yml=:
#+begin_src yaml
packages:
  - name: do-serverless
    actions:
      - name: core
        runtime: nodejs:default
#+end_src

OK! Let's see where we're at:
#+begin_src bash
shadow-cljs release core
doctl serverless deploy .
#+end_src

Now we can go to the Functions tab on DO's site and run our function by first going to the function namespace, clicking on the name of the function, and hitting Run. I get this error:
#+begin_src txt
2023-01-12T11:14:08.172732642Z stdout: Action entrypoint 'main' is not a function.
#+end_src
What tha...

At this point, I dug around and found that DO maintains a bunch of sample functions. Going to the [[https://web.archive.org/web/20220728083446/https://github.com/digitalocean/sample-functions-nodejs-qrcode/blob/main/packages/qr/qr/qr.js][Node one]], we see this:
#+begin_src javascript
exports.main = (args) => { ... }
#+end_src

Huh. OK, so let's do that in our example, =src/main/core.cljs=:
#+begin_src clojurescript
(ns core)

(defn main [& args]
  (println "hello!")
  (println "args: " args))

(set! js/exports.main main)
#+end_src

And re-build and deploy.
#+begin_src
2023-01-12T11:22:14.933096349Z stdout: hello!
2023-01-12T11:22:14.933797937Z stdout: args:  nil
2023-01-12T11:22:14.961195498Z stdout: hello!
2023-01-12T11:22:14.982016323Z stdout: args:  (#js {} ... // output truncated
#+end_src

Ok, so when our function executes, our =main= gets executed twice. I don't know why this happens. If I run our compiled javascript file locally with =node=, I only see one execution:
#+begin_src
$ node packages/do-serverless/core/core.js
hello!
args:  nil
#+end_src

So, OK, some detail that's above my head. My use case for serverless would, uh, not do well with running everything twice. So, what to do?

Well, we know whatever we tell =shadow= our =main= is will get run. And we also know whatever we tell DO our main is (the =js/exports.main= bit) will also run. Well, I only care about the DO side of things!

#+begin_src clojurescript
(ns core)

(defn my-actual-function [& args]
  (println "hello!")
  (println "args: " args))

(defn main [])

(set! js/exports.main my-actual-function)
#+end_src

#+begin_src
2023-01-12T11:28:57.786063804Z stdout: hello!
2023-01-12T11:28:57.793552189Z stdout: args:  (#js {} ... // output truncated
#+end_src

Neat!
