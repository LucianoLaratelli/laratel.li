#+title: Posts
#+hugo_base_dir: resources/
#+hugo_front_matter_format: yaml

* Posts
** TODO (unordered) Thoughts on task ordering
:PROPERTIES:
:EXPORT_FILE_NAME: task-ordering
:EXPORT_HUGO_PUBLISHDATE: <2023-07-16 Sun>
:END:
** Setting up mu4e with iCloud custom domains with Doom Emacs on Arch Linux
:PROPERTIES:
:EXPORT_FILE_NAME: mu4e_doom_emacs
:EXPORT_HUGO_PUBLISHDATE: <2022-04-18 Mon 20:32>
:END:
Here's how I set up =mu4e= with Doom Emacs on Arch Linux for my custom domain
hosted on iCloud. I'm using =mbsync=, =mu=, and =msmpt=. I originally went with
a systemd timer as detailed in the first two sections as recommended in the [[https://wiki.archlinux.org/title/isync#Calling_mbsync_automatically][Arch
wiki]], but =mu4e= actually has a built-in functionality to deal with this for us.
Note that what I've written here is the /minimum/ I needed to do to actually
sync, send, and read emails from =emacs=. There's a lot more you can do.

*** Configuration files

In =init.el=, under =:email=
#+begin_src emacs-lisp
(mu4e +org)
#+end_src

=config.el=:
#+begin_src emacs-lisp
(set-email-account! "icloud"
  '((mu4e-sent-folder       . "/icloud/Sent")
    (mu4e-drafts-folder     . "/icloud/Drafts")
    (mu4e-trash-folder      . "/icloud/Trash")
    (mu4e-refile-folder     . "/icloud/Archive")
    (smtpmail-smtp-user     . "lucianolaratelli")
    (mu4e-compose-signature . "\n\nLuciano"))
  t)

(after! mu4e
  (setq sendmail-program (executable-find "msmtp")
        send-mail-function #'smtpmail-send-it
        smtpmail-stream-type 'starttls
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-send-mail-function #'message-send-mail-with-sendmail))
#+end_src

In =$HOME/.config/system/user/mbsync.timer=:
#+begin_src systemd
[Unit]
Description=Mailbox synchronization timer

[Timer]
OnBootSec=1m
OnUnitActiveSec=5m
Unit=mbsync.service

[Install]
WantedBy=timers.target
#+end_src

=$HOME/.config/system/user/mbsync.service=:
#+begin_src systemd
[Unit]
Description=Mailbox synchronization service

[Service]
Type=oneshot
ExecStart=/usr/bin/mbsync --verbose --all

[Install]
WantedBy=default.target
#+end_src

=$HOME/.mbsyncrc=:
#+begin_src config
# imap account information
IMAPAccount icloud
Host imap.mail.me.com
User lucianolaratelli@icloud.com
PassCmd "secret-tool lookup email luciano@laratel.li"
SSLType IMAPS
Port 993

# remote storage (use the imap account specified above)
IMAPStore icloud-remote
Account icloud

# local storage
MaildirStore icloud-local
Path ~/Dropbox/mailbox/icloud/
Inbox ~/Dropbox/mailbox/icloud*Inbox
Subfolders Verbatim

# channel to remote storage
Channel icloud
Far :icloud-remote:
Near :icloud-local:
Patterns *
Create Near
Sync All
Expunge Both
SyncState *
#+end_src

The crucial part when you're using a custom domain hosted on iCloud is to use
your *iCloud email address* instead of the custom one. I thought this was a bug
with custom domains (I've run into another one) but I called Apple's support and
they told me I needed to use the iCloud email address. You can find this on an
iPhone or iPad by going to Settings, tapping on your name up top, and tapping on
=Name, Phone Numbers, Email=. I had =@me.com= and =@icloud.com= emails there. I
went with the =@icloud.com= one. [[https://support.apple.com/en-us/HT202304][Apple's docs]] on third-party iCloud clients say
you can use just the part before the domain, but I included the whole thing just
in case. Without further ado, =$HOME/.msmptrc=:
#+begin_src config
defaults
tls_trust_file /etc/ssl/certs/ca-certificates.crt
logfile ~/.maildir/msmtp.log
protocol smtp

account icloud
auth on
host smtp.mail.me.com
port 587
protocol smtp
from luciano@laratel.li
user ${ICLOUD_EMAIL_ADDRESS}
passwordeval "secret-tool lookup email luciano@laratel.li"
tls on
tls_starttls on

account default : icloud
#+end_src

I have =tls= and =tls_starttls= both on. I think I only need one of these, but I
don't want to muck with testing my mail configuration to get a blog post out.
You might need one, the other, or both. Exercise for the reader!

I was originally using =gpg= as described by Erich Grunewald in his very helpful
[[https://www.erichgrunewald.com/posts/setting-up-gmail-in-doom-emacs-using-mbsync-and-mu4e/#(optionally)-store-your-password-in-an-encrypted-file][post]], but unlocking my yubikey every five minutes became a pain and I figured my
login keychain was secure enough for my (unsophisticated) threat model.

*** Install and enable packages

#+begin_src bash
yay mbsync
sudo pacman -S msmtp
yay mu mu4e # impossible to find mu otherwise

mkdir -p ~/home/Dropbox/mailbox/icloud
mbsync -Va
mu init -m ~/Dropbox/mailbox --my-address luciano@laratel.li
mu index

systemctl enable --user --now mbsync
systemctl enable --user --now mbsync.timer

doom sync
#+end_src

At this point you can run =emacs=, =<SPC> o m=, and get to emailin'!

*** Moving away from systemd

This was working fine but I wasn't getting in-=emacs= notifications when new
emails came in, even though =mbsync= was running on schedule! So I got rid of
the =mbsync.timer= service with =systemctl disable --now --user mbsync.timer=. I
kept =mbsync.service= so that my email syncs when I log in for the day. Then, in
my =config.el=:

#+begin_src emacs-lisp
(after! mu4e (setq mu4e-get-mail-command "mbsync --verbose --all"
                   mu4e-update-interval 300))
#+end_src

I restarted =emacs= and I was good to go.

*** Resources
Tecosaur's awe-inspiring [[https://tecosaur.github.io/emacs-config/config.html#fetching-systemd][config]]

The already-mentioned [[https://www.erichgrunewald.com/posts/setting-up-gmail-in-doom-emacs-using-mbsync-and-mu4e/#(optionally)-store-your-password-in-an-encrypted-file][post]] from Erich Grunewald

The Doom Emacs =mu4e= module [[https://github.com/hlissner/doom-emacs/tree/develop/modules/email/mu4e][documentation]] (also from Tecosaur)

[[https://github.com/kzar/davemail/blob/main/.mbsyncrc][davemail]]

This [[https://macowners.club/posts/email-emacs-mu4e-macos/#storing-trusted-root-certificates][article]], though it focuses on macOS
** Using CLJS and shadow-cljs for serverless DigitalOcean Functions
:PROPERTIES:
:EXPORT_FILE_NAME: cljs-digitalocean-serverless
:EXPORT_HUGO_PUBLISHDATE: <2023-01-11 Wed 20:08>
:END:

DigitalOcean (DO) [[https://www.digitalocean.com/products/functions][Functions]]: "a serverless computing solution that runs on-demand, enabling you to focus on your code, scale instantly with confidence, and save costs by eliminating the need to maintain servers." Since I'm a fanatic, I would like to write some Clojure for my serverless use case. Because DO offers Node as a runtime, we're able to use ClojureScript to write code and deploy it to the serverless, er, server.

Source code for this blog post is [[https://git.sr.ht/~luciano/cljs-digitalocean-serverless-function][available]].

You'll need a DO account. Log in, select the appropriate team, then select =Functions= on the left-hand column. Create a function namespace and you're ready to go.

Next we need the =doctl= binary. Here's what I did:
#+begin_src bash
brew install doctl
doctl auth init
doctl serverless install
doctl serverless connect
#+end_src

This gets you authenticated with DO so you can deploy from the command line.

#+begin_src bash
npx create-cljs-project do_serverless
cd do_serverless
#+end_src

Now, let's edit the generated =shadow.cljs= a bit. Add this map as the value under =:builds=:
#+begin_src clojure
{:core {:target :node-script
         :main core/main
         :output-to "packages/do-serverless/core/core.js"}}
#+end_src

Create =src/main/core.cljs= and define =main= in it:
#+begin_src clojure
(ns core)

(defn main [])
#+end_src

Create =packages/do-serverless/core/package.json= with this in it:
#+begin_src json
{
  "name": "core",
  "version": "1.0.0",
  "description": "CLJS on DO!",
  "main": "core.js",
  "dependencies": {
    "source-map-support": "^0.5.21"
  },
  "devDependencies": {}
}
#+end_src

Lastly, create =project.yml=:
#+begin_src yaml
packages:
  - name: do-serverless
    actions:
      - name: core
        runtime: nodejs:default
#+end_src

OK! Let's see where we're at:
#+begin_src bash
shadow-cljs release core
doctl serverless deploy .
#+end_src

Now we can go to the Functions tab on DO's site and run our function by first going to the function namespace, clicking on the name of the function, and hitting Run. I get this error:
#+begin_src txt
2023-01-12T11:14:08.172732642Z stdout: Action entrypoint 'main' is not a function.
#+end_src
What tha...

At this point, I dug around and found that DO maintains a bunch of sample functions. Going to the [[https://web.archive.org/web/20220728083446/https://github.com/digitalocean/sample-functions-nodejs-qrcode/blob/main/packages/qr/qr/qr.js][Node one]], we see this:
#+begin_src javascript
exports.main = (args) => { ... }
#+end_src

Huh. OK, so let's do that in our example, =src/main/core.cljs=:
#+begin_src clojurescript
(ns core)

(defn main [& args]
  (println "hello!")
  (println "args: " args))

(set! js/exports.main main)
#+end_src

And re-build and deploy.
#+begin_src
2023-01-12T11:22:14.933096349Z stdout: hello!
2023-01-12T11:22:14.933797937Z stdout: args:  nil
2023-01-12T11:22:14.961195498Z stdout: hello!
2023-01-12T11:22:14.982016323Z stdout: args:  (#js {} ... // output truncated
#+end_src

Ok, so when our function executes, our =main= gets executed twice. I don't know why this happens. If I run our compiled javascript file locally with =node=, I only see one execution:
#+begin_src
$ node packages/do-serverless/core/core.js
hello!
args:  nil
#+end_src

So, OK, some detail that's above my head. My use case for serverless would, uh, not do well with running everything twice. So, what to do?

Well, we know whatever we tell =shadow= our =main= is will get run. And we also know whatever we tell DO our main is (the =js/exports.main= bit) will also run. Well, I only care about the DO side of things!

#+begin_src clojurescript
(ns core)

(defn my-actual-function [& args]
  (println "hello!")
  (println "args: " args))

(defn main [])

(set! js/exports.main my-actual-function)
#+end_src

#+begin_src
2023-01-12T11:28:57.786063804Z stdout: hello!
2023-01-12T11:28:57.793552189Z stdout: args:  (#js {} ... // output truncated
#+end_src

Neat!
